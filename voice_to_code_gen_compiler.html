<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Voice to Code - Compiler Construction Project (Part 1)</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font-family: 'Inter', sans-serif;
    background: #f9fafb;
    color: #374151;
    line-height: 1.5;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  h1, h2, h3 {
    margin: 0 0 16px 0;
    font-weight: 700;
    color: #111827;
  }
  h1 {
    font-size: 2.5rem;
  }
  h2 {
    font-size: 1.75rem;
  }
  h3 {
    font-size: 1.25rem;
  }

  /* Container */
  .container {
    max-width: 1200px;
    margin: auto;
    padding: 24px 16px;
    flex: 1 1 auto;
    display: flex;
    flex-direction: column;
  }

  /* Header */
  header {
    background: linear-gradient(90deg, #6366f1, #06b6d4);
    color: white;
    padding: 16px 24px;
    text-align: center;
    user-select: none;
    box-shadow: 0 4px 10px rgb(0 0 0 / 0.1);
  }

  /* Layout for main content */
  main {
    flex: 1;
    overflow: hidden;
    display: flex;
    flex-direction: row;
    gap: 24px;
    margin-top: 16px;
  }

  /* Left panel: code input and voice */
  .panel-left {
    flex: 1 1 30%;
    background: white;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 6px 15px rgb(0 0 0 / 0.05);
    display: flex;
    flex-direction: column;
  }

  textarea {
    flex: 1 1 auto;
    resize: vertical;
    font-family: 'Source Code Pro', monospace, monospace;
    font-size: 14px;
    padding: 12px;
    border: 1.5px solid #d1d5db;
    border-radius: 8px;
    background: #f9fafb;
    color: #111827;
    min-height: 180px;
    line-height: 1.4;
    transition: border-color 0.3s ease;
  }
  textarea:focus {
    border-color: #6366f1;
    outline: none;
    background: white;
  }

  button {
    background: linear-gradient(135deg, #6366f1, #06b6d4);
    border: none;
    color: white;
    font-weight: 600;
    padding: 12px 24px;
    font-size: 14px;
    border-radius: 8px;
    cursor: pointer;
    margin-top: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  button:hover,
  button:focus {
    background: linear-gradient(135deg, #4f46e5, #0891b2);
  }
  button:disabled {
    background: #a5b4fc;
    cursor: not-allowed;
  }

  .panel-middle {
    flex: 1 1 70%;
    background: white;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 6px 15px rgb(0 0 0 / 0.05);
    overflow-y: auto;
    max-height: 80vh;
  }

  /* Stage box */
  .stage {
    margin-bottom: 32px;
  }
  .stage:last-child {
    margin-bottom: 0;
  }
  .stage h3 {
    margin-bottom: 12px;
    color: #4b5563;
  }

  /* Tokens output */
  .tokens, .ast, .code-output {
    background: #f3f4f6;
    border-radius: 8px;
    padding: 16px;
    font-family: 'Source Code Pro', monospace, monospace;
    font-size: 14px;
    color: #1f2937;
    max-height: 200px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-word;
    border: 1px solid #e5e7eb;
  }

  .error {
    color: #dc2626;
    font-weight: 600;
    background: #fee2e2;
    padding: 12px 16px;
    border-radius: 8px;
    margin-top: 8px;
    font-size: 0.9rem;
  }

  /* Material Icons */
  @import url('https://fonts.googleapis.com/icon?family=Material+Icons');

  .material-icons {
    font-family: 'Material Icons';
    font-weight: normal;
    font-style: normal;
    font-size: 20px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    direction: ltr;
    -webkit-font-feature-settings: 'liga';
    -webkit-font-smoothing: antialiased;
  }

  /* Section titles */
  .section-title {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 12px;
    border-bottom: 2px solid #e5e7eb;
    padding-bottom: 6px;
    color: #374151;
  }

  .panel-middle::-webkit-scrollbar {
    width: 8px;
  }
  .panel-middle::-webkit-scrollbar-thumb {
    background: #a5b4fc;
    border-radius: 4px;
  }
  .panel-middle::-webkit-scrollbar-track {
    background: transparent;
  }

</style>
</head>

<body>
    <header>
        <h1>Voice to Code - Compiler Construction Project</h1>
      </header>
      <div class="container">
        <div style="display:flex; flex-direction: row; gap: 24px; flex-wrap: wrap;">
          <section class="panel-left" aria-label="Input code and voice transcription section">
            <h2 class="section-title">Input Code / Voice to Code</h2>
            <textarea id="code-input" aria-label="Source code input area" placeholder="Type your code here or use voice input..."></textarea>
            <button id="voice-btn" aria-pressed="false" aria-label="Start voice recognition to input code" type="button">
              <span class="material-icons" aria-hidden="true">keyboard_voice</span> Start Voice Input
            </button>
          </section>
      
          <section class="panel-middle" aria-live="polite" aria-label="Compiler processing stages output">
            <h2 class="section-title">Compiler Stages</h2>
      
            <!-- Lexical Analysis Stage -->
            <section class="stage" id="lexical-stage">
              <h3>1. Lexical Analysis & Tokenization</h3>
              <pre class="tokens" id="tokens-output" aria-label="Tokens output area"></pre>
              <div class="error" id="lexical-error" role="alert" aria-live="assertive" style="display:none"></div>
            </section>
      
            <!-- Syntactical Analysis Stage -->
            <section class="stage" id="syntax-stage">
              <h3>2. Syntactical Analysis (Parsing and Syntax Check)</h3>
              <pre class="tokens" id="syntax-output" aria-label="Syntax analysis output area"></pre>
              <div class="error" id="syntax-error" role="alert" aria-live="assertive" style="display:none"></div>
            </section>
      
            <!-- AST Generation -->
            <section class="stage" id="ast-stage">
              <h3>3. Abstract Syntax Tree (AST) Generation</h3>
              <pre class="ast" id="ast-output" aria-label="AST output area"></pre>
            </section>
      
            <!-- Semantic Analysis -->
            <section class="stage" id="semantic-stage">
              <h3>4. Semantic Analysis</h3>
              <pre class="tokens" id="semantic-output" aria-label="Semantic analysis output area"></pre>
              <div class="error" id="semantic-error" role="alert" aria-live="assertive" style="display:none"></div>
            </section>
      
            <!-- Code Generation Stage -->
            <section class="stage" id="codegen-stage">
              <h3>5. Final Code Generation</h3>
              <pre class="code-output" id="codegen-output" aria-label="Final generated code output area"></pre>
            </section>
          </section>
        </div>
      </div>

      <script>
          const codeInput = document.getElementById('code-input');
  const voiceBtn = document.getElementById('voice-btn');
  const tokensOutput = document.getElementById('tokens-output');
  const lexicalError = document.getElementById('lexical-error');
  const syntaxOutput = document.getElementById('syntax-output');
  const syntaxError = document.getElementById('syntax-error');
  const astOutput = document.getElementById('ast-output');
  const semanticOutput = document.getElementById('semantic-output');
  const semanticError = document.getElementById('semantic-error');
  const codegenOutput = document.getElementById('codegen-output');

  // Lexical Analysis - Tokenizer
  function tokenize(code) {
    lexicalError.style.display = 'none';
    const tokens = [];
    const tokenSpecs = [
      ['WHITESPACE', /^\s+/],
      ['NUMBER', /^\d+(\.\d+)?\b/],
      ['IDENTIFIER', /^[a-zA-Z_]\w*/],
      ['OPERATOR', /^[+\-*\/=<>!]+/],
      ['DELIMITER', /^[\(\)\{\};,\.]/],
      ['STRING', /^"([^"\\]|\\.)*"/],
      ['UNKNOWN', /^./]
    ];

    let pos = 0;

    while (pos < code.length) {
      let match = null;
      let type = null;

      for (const [tokType, regex] of tokenSpecs) {
        match = code.slice(pos).match(regex);
        if (match) {
          if (tokType !== 'WHITESPACE') {
            if (tokType === 'UNKNOWN') {
              lexicalError.textContent = `Unrecognized token starting at "${match[0]}" near position ${pos}.`;
              lexicalError.style.display = 'block';
              return [];
            }
            tokens.push({ type: tokType, value: match[0] });
          }
          pos += match[0].length;
          break;
        }
      }
      if (!match) {
        lexicalError.textContent = `Unknown error tokenizing at position ${pos}.`;
        lexicalError.style.display = 'block';
        return [];
      }
    }
    return tokens;
  }

  // Simple parser for demonstration: checks token sequence for simple grammar like variable declarations and assignments
  function parse(tokens) {
    syntaxError.style.display = 'none';
    let pos = 0;

    function expect(type, value = null) {
      if (pos < tokens.length) {
        const tok = tokens[pos];
        if (tok.type === type && (value === null || tok.value === value)) {
          pos++;
          return tok;
        }
        syntaxError.textContent = `Expected ${value || type} but found ${tok.value} at token ${pos + 1}`;
        syntaxError.style.display = 'block';
        throw new Error(syntaxError.textContent);
      }
      syntaxError.textContent = `Unexpected end of input, expected ${value || type}`;
      syntaxError.style.display = 'block';
      throw new Error(syntaxError.textContent);
    }

    function parseExpression() {
      if (pos >= tokens.length) {
        throw new Error('Unexpected end of input in expression');
      }
      const tok = tokens[pos];
      if (tok.type === 'IDENTIFIER' || tok.type === 'NUMBER') {
        pos++;
        return { type: 'Literal', value: tok.value, tokenType: tok.type };
      } else {
        throw new Error(`Invalid expression token '${tok.value}' at position ${pos + 1}`);
      }
    }

    function parseVarDecl() {
      expect('IDENTIFIER', 'var');
      let idTok = expect('IDENTIFIER');
      let init = null;
      if (pos < tokens.length && tokens[pos].type === 'OPERATOR' && tokens[pos].value === '=') {
        pos++;
        init = parseExpression();
      }
      expect('DELIMITER', ';');
      return { type: 'VarDeclaration', identifier: idTok.value, init };
    }

    function parseAssignment() {
      let idTok = expect('IDENTIFIER');
      expect('OPERATOR', '=');
      let expr = parseExpression();
      expect('DELIMITER', ';');
      return { type: 'AssignmentExpression', identifier: idTok.value, expression: expr };
    }

    function parseStatement() {
      if (pos >= tokens.length) return null;
      const tok = tokens[pos];
      if (tok.type === 'IDENTIFIER' && tok.value === 'var') {
        return parseVarDecl();
      }
      if (tok.type === 'IDENTIFIER') {
        // Lookahead for assignment
        if (pos + 1 < tokens.length && tokens[pos + 1].type === 'OPERATOR' && tokens[pos + 1].value === '=') {
          return parseAssignment();
        }
        syntaxError.textContent = `Unexpected token sequence starting at '${tok.value}', expected assignment or declaration`;
        syntaxError.style.display = 'block';
        throw new Error(syntaxError.textContent);
      }
      syntaxError.textContent = `Unsupported statement starting at '${tok.value}'`;
      syntaxError.style.display = 'block';
      throw new Error(syntaxError.textContent);
    }

    const ast = { type: 'Program', body: [] };

    try {
      while (pos < tokens.length) {
        let stmt = parseStatement();
        if (stmt === null) break;
        ast.body.push(stmt);
      }
    } catch (e) {
      return null;
    }
    return ast;
  }
      </script>
</body>
</html>